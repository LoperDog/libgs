// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rest.proto

#ifndef PROTOBUF_INCLUDED_rest_2eproto
#define PROTOBUF_INCLUDED_rest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_rest_2eproto 

namespace protobuf_rest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_rest_2eproto
class Chatmsg;
class ChatmsgDefaultTypeInternal;
extern ChatmsgDefaultTypeInternal _Chatmsg_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Roominsert;
class RoominsertDefaultTypeInternal;
extern RoominsertDefaultTypeInternal _Roominsert_default_instance_;
class Roomlist;
class RoomlistDefaultTypeInternal;
extern RoomlistDefaultTypeInternal _Roomlist_default_instance_;
class Roomlist_RoomlistEntry_DoNotUse;
class Roomlist_RoomlistEntry_DoNotUseDefaultTypeInternal;
extern Roomlist_RoomlistEntry_DoNotUseDefaultTypeInternal _Roomlist_RoomlistEntry_DoNotUse_default_instance_;
class Roommake;
class RoommakeDefaultTypeInternal;
extern RoommakeDefaultTypeInternal _Roommake_default_instance_;
class SearchRequest;
class SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
namespace google {
namespace protobuf {
template<> ::Chatmsg* Arena::CreateMaybeMessage<::Chatmsg>(Arena*);
template<> ::Login* Arena::CreateMaybeMessage<::Login>(Arena*);
template<> ::Roominsert* Arena::CreateMaybeMessage<::Roominsert>(Arena*);
template<> ::Roomlist* Arena::CreateMaybeMessage<::Roomlist>(Arena*);
template<> ::Roomlist_RoomlistEntry_DoNotUse* Arena::CreateMaybeMessage<::Roomlist_RoomlistEntry_DoNotUse>(Arena*);
template<> ::Roommake* Arena::CreateMaybeMessage<::Roommake>(Arena*);
template<> ::SearchRequest* Arena::CreateMaybeMessage<::SearchRequest>(Arena*);
}  // namespace protobuf
}  // namespace google

enum Login_MessageType {
  Login_MessageType_Success = 0,
  Login_MessageType_Overlap = 1,
  Login_MessageType_Failed = 2,
  Login_MessageType_Login_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Login_MessageType_Login_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Login_MessageType_IsValid(int value);
const Login_MessageType Login_MessageType_MessageType_MIN = Login_MessageType_Success;
const Login_MessageType Login_MessageType_MessageType_MAX = Login_MessageType_Failed;
const int Login_MessageType_MessageType_ARRAYSIZE = Login_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Login_MessageType_descriptor();
inline const ::std::string& Login_MessageType_Name(Login_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Login_MessageType_descriptor(), value);
}
inline bool Login_MessageType_Parse(
    const ::std::string& name, Login_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Login_MessageType>(
    Login_MessageType_descriptor(), name, value);
}
enum Roommake_MessageType {
  Roommake_MessageType_Success = 0,
  Roommake_MessageType_Overlap = 1,
  Roommake_MessageType_Failed = 2,
  Roommake_MessageType_Roommake_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Roommake_MessageType_Roommake_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Roommake_MessageType_IsValid(int value);
const Roommake_MessageType Roommake_MessageType_MessageType_MIN = Roommake_MessageType_Success;
const Roommake_MessageType Roommake_MessageType_MessageType_MAX = Roommake_MessageType_Failed;
const int Roommake_MessageType_MessageType_ARRAYSIZE = Roommake_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Roommake_MessageType_descriptor();
inline const ::std::string& Roommake_MessageType_Name(Roommake_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Roommake_MessageType_descriptor(), value);
}
inline bool Roommake_MessageType_Parse(
    const ::std::string& name, Roommake_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Roommake_MessageType>(
    Roommake_MessageType_descriptor(), name, value);
}
enum Roominsert_MessageType {
  Roominsert_MessageType_Success = 0,
  Roominsert_MessageType_Overlap = 1,
  Roominsert_MessageType_Failed = 2,
  Roominsert_MessageType_Roominsert_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Roominsert_MessageType_Roominsert_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Roominsert_MessageType_IsValid(int value);
const Roominsert_MessageType Roominsert_MessageType_MessageType_MIN = Roominsert_MessageType_Success;
const Roominsert_MessageType Roominsert_MessageType_MessageType_MAX = Roominsert_MessageType_Failed;
const int Roominsert_MessageType_MessageType_ARRAYSIZE = Roominsert_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Roominsert_MessageType_descriptor();
inline const ::std::string& Roominsert_MessageType_Name(Roominsert_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Roominsert_MessageType_descriptor(), value);
}
inline bool Roominsert_MessageType_Parse(
    const ::std::string& name, Roominsert_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Roominsert_MessageType>(
    Roominsert_MessageType_descriptor(), name, value);
}
// ===================================================================

class SearchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SearchRequest) */ {
 public:
  SearchRequest();
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SearchRequest* other);
  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const final {
    return CreateMaybeMessage<SearchRequest>(NULL);
  }

  SearchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string query = 1;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // int32 page_number = 2;
  void clear_page_number();
  static const int kPageNumberFieldNumber = 2;
  ::google::protobuf::int32 page_number() const;
  void set_page_number(::google::protobuf::int32 value);

  // int32 result_per_page = 3;
  void clear_result_per_page();
  static const int kResultPerPageFieldNumber = 3;
  ::google::protobuf::int32 result_per_page() const;
  void set_result_per_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SearchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::int32 page_number_;
  ::google::protobuf::int32 result_per_page_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return CreateMaybeMessage<Login>(NULL);
  }

  Login* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Login_MessageType MessageType;
  static const MessageType Success =
    Login_MessageType_Success;
  static const MessageType Overlap =
    Login_MessageType_Overlap;
  static const MessageType Failed =
    Login_MessageType_Failed;
  static inline bool MessageType_IsValid(int value) {
    return Login_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Login_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Login_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Login_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Login_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Login_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Login_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .Login.MessageType returndata = 2;
  int returndata_size() const;
  void clear_returndata();
  static const int kReturndataFieldNumber = 2;
  ::Login_MessageType returndata(int index) const;
  void set_returndata(int index, ::Login_MessageType value);
  void add_returndata(::Login_MessageType value);
  const ::google::protobuf::RepeatedField<int>& returndata() const;
  ::google::protobuf::RepeatedField<int>* mutable_returndata();

  // string nickname = 1;
  void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> returndata_;
  mutable int _returndata_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Roomlist_RoomlistEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Roomlist_RoomlistEntry_DoNotUse, 
    ::google::protobuf::int64, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Roomlist_RoomlistEntry_DoNotUse, 
    ::google::protobuf::int64, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Roomlist_RoomlistEntry_DoNotUse();
  Roomlist_RoomlistEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Roomlist_RoomlistEntry_DoNotUse& other);
  static const Roomlist_RoomlistEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Roomlist_RoomlistEntry_DoNotUse*>(&_Roomlist_RoomlistEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Roomlist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Roomlist) */ {
 public:
  Roomlist();
  virtual ~Roomlist();

  Roomlist(const Roomlist& from);

  inline Roomlist& operator=(const Roomlist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Roomlist(Roomlist&& from) noexcept
    : Roomlist() {
    *this = ::std::move(from);
  }

  inline Roomlist& operator=(Roomlist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Roomlist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roomlist* internal_default_instance() {
    return reinterpret_cast<const Roomlist*>(
               &_Roomlist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Roomlist* other);
  friend void swap(Roomlist& a, Roomlist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Roomlist* New() const final {
    return CreateMaybeMessage<Roomlist>(NULL);
  }

  Roomlist* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Roomlist>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Roomlist& from);
  void MergeFrom(const Roomlist& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roomlist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int64, string> roomlist = 1;
  int roomlist_size() const;
  void clear_roomlist();
  static const int kRoomlistFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >&
      roomlist() const;
  ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >*
      mutable_roomlist();

  // int64 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Roomlist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Roomlist_RoomlistEntry_DoNotUse,
      ::google::protobuf::int64, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > roomlist_;
  ::google::protobuf::int64 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Roommake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Roommake) */ {
 public:
  Roommake();
  virtual ~Roommake();

  Roommake(const Roommake& from);

  inline Roommake& operator=(const Roommake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Roommake(Roommake&& from) noexcept
    : Roommake() {
    *this = ::std::move(from);
  }

  inline Roommake& operator=(Roommake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Roommake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roommake* internal_default_instance() {
    return reinterpret_cast<const Roommake*>(
               &_Roommake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Roommake* other);
  friend void swap(Roommake& a, Roommake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Roommake* New() const final {
    return CreateMaybeMessage<Roommake>(NULL);
  }

  Roommake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Roommake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Roommake& from);
  void MergeFrom(const Roommake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roommake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Roommake_MessageType MessageType;
  static const MessageType Success =
    Roommake_MessageType_Success;
  static const MessageType Overlap =
    Roommake_MessageType_Overlap;
  static const MessageType Failed =
    Roommake_MessageType_Failed;
  static inline bool MessageType_IsValid(int value) {
    return Roommake_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Roommake_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Roommake_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Roommake_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Roommake_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Roommake_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Roommake_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int64 returndata = 2;
  int returndata_size() const;
  void clear_returndata();
  static const int kReturndataFieldNumber = 2;
  ::google::protobuf::int64 returndata(int index) const;
  void set_returndata(int index, ::google::protobuf::int64 value);
  void add_returndata(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      returndata() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_returndata();

  // string RoomName = 1;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // @@protoc_insertion_point(class_scope:Roommake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > returndata_;
  mutable int _returndata_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Roominsert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Roominsert) */ {
 public:
  Roominsert();
  virtual ~Roominsert();

  Roominsert(const Roominsert& from);

  inline Roominsert& operator=(const Roominsert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Roominsert(Roominsert&& from) noexcept
    : Roominsert() {
    *this = ::std::move(from);
  }

  inline Roominsert& operator=(Roominsert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Roominsert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roominsert* internal_default_instance() {
    return reinterpret_cast<const Roominsert*>(
               &_Roominsert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Roominsert* other);
  friend void swap(Roominsert& a, Roominsert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Roominsert* New() const final {
    return CreateMaybeMessage<Roominsert>(NULL);
  }

  Roominsert* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Roominsert>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Roominsert& from);
  void MergeFrom(const Roominsert& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roominsert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Roominsert_MessageType MessageType;
  static const MessageType Success =
    Roominsert_MessageType_Success;
  static const MessageType Overlap =
    Roominsert_MessageType_Overlap;
  static const MessageType Failed =
    Roominsert_MessageType_Failed;
  static inline bool MessageType_IsValid(int value) {
    return Roominsert_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Roominsert_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Roominsert_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Roominsert_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Roominsert_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Roominsert_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Roominsert_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int64 returndata = 2;
  int returndata_size() const;
  void clear_returndata();
  static const int kReturndataFieldNumber = 2;
  ::google::protobuf::int64 returndata(int index) const;
  void set_returndata(int index, ::google::protobuf::int64 value);
  void add_returndata(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      returndata() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_returndata();

  // int64 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Roominsert)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > returndata_;
  mutable int _returndata_cached_byte_size_;
  ::google::protobuf::int64 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chatmsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Chatmsg) */ {
 public:
  Chatmsg();
  virtual ~Chatmsg();

  Chatmsg(const Chatmsg& from);

  inline Chatmsg& operator=(const Chatmsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chatmsg(Chatmsg&& from) noexcept
    : Chatmsg() {
    *this = ::std::move(from);
  }

  inline Chatmsg& operator=(Chatmsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chatmsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chatmsg* internal_default_instance() {
    return reinterpret_cast<const Chatmsg*>(
               &_Chatmsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Chatmsg* other);
  friend void swap(Chatmsg& a, Chatmsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chatmsg* New() const final {
    return CreateMaybeMessage<Chatmsg>(NULL);
  }

  Chatmsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chatmsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chatmsg& from);
  void MergeFrom(const Chatmsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chatmsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chat = 1;
  void clear_chat();
  static const int kChatFieldNumber = 1;
  const ::std::string& chat() const;
  void set_chat(const ::std::string& value);
  #if LANG_CXX11
  void set_chat(::std::string&& value);
  #endif
  void set_chat(const char* value);
  void set_chat(const char* value, size_t size);
  ::std::string* mutable_chat();
  ::std::string* release_chat();
  void set_allocated_chat(::std::string* chat);

  // @@protoc_insertion_point(class_scope:Chatmsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SearchRequest

// string query = 1;
inline void SearchRequest::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchRequest::query() const {
  // @@protoc_insertion_point(field_get:SearchRequest.query)
  return query_.GetNoArena();
}
inline void SearchRequest::set_query(const ::std::string& value) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SearchRequest.query)
}
#if LANG_CXX11
inline void SearchRequest::set_query(::std::string&& value) {
  
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SearchRequest.query)
}
#endif
inline void SearchRequest::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SearchRequest.query)
}
inline void SearchRequest::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SearchRequest.query)
}
inline ::std::string* SearchRequest::mutable_query() {
  
  // @@protoc_insertion_point(field_mutable:SearchRequest.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchRequest::release_query() {
  // @@protoc_insertion_point(field_release:SearchRequest.query)
  
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:SearchRequest.query)
}

// int32 page_number = 2;
inline void SearchRequest::clear_page_number() {
  page_number_ = 0;
}
inline ::google::protobuf::int32 SearchRequest::page_number() const {
  // @@protoc_insertion_point(field_get:SearchRequest.page_number)
  return page_number_;
}
inline void SearchRequest::set_page_number(::google::protobuf::int32 value) {
  
  page_number_ = value;
  // @@protoc_insertion_point(field_set:SearchRequest.page_number)
}

// int32 result_per_page = 3;
inline void SearchRequest::clear_result_per_page() {
  result_per_page_ = 0;
}
inline ::google::protobuf::int32 SearchRequest::result_per_page() const {
  // @@protoc_insertion_point(field_get:SearchRequest.result_per_page)
  return result_per_page_;
}
inline void SearchRequest::set_result_per_page(::google::protobuf::int32 value) {
  
  result_per_page_ = value;
  // @@protoc_insertion_point(field_set:SearchRequest.result_per_page)
}

// -------------------------------------------------------------------

// Login

// string nickname = 1;
inline void Login::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::nickname() const {
  // @@protoc_insertion_point(field_get:Login.nickname)
  return nickname_.GetNoArena();
}
inline void Login::set_nickname(const ::std::string& value) {
  
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.nickname)
}
#if LANG_CXX11
inline void Login::set_nickname(::std::string&& value) {
  
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.nickname)
}
#endif
inline void Login::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.nickname)
}
inline void Login::set_nickname(const char* value, size_t size) {
  
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.nickname)
}
inline ::std::string* Login::mutable_nickname() {
  
  // @@protoc_insertion_point(field_mutable:Login.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_nickname() {
  // @@protoc_insertion_point(field_release:Login.nickname)
  
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    
  } else {
    
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:Login.nickname)
}

// repeated .Login.MessageType returndata = 2;
inline int Login::returndata_size() const {
  return returndata_.size();
}
inline void Login::clear_returndata() {
  returndata_.Clear();
}
inline ::Login_MessageType Login::returndata(int index) const {
  // @@protoc_insertion_point(field_get:Login.returndata)
  return static_cast< ::Login_MessageType >(returndata_.Get(index));
}
inline void Login::set_returndata(int index, ::Login_MessageType value) {
  returndata_.Set(index, value);
  // @@protoc_insertion_point(field_set:Login.returndata)
}
inline void Login::add_returndata(::Login_MessageType value) {
  returndata_.Add(value);
  // @@protoc_insertion_point(field_add:Login.returndata)
}
inline const ::google::protobuf::RepeatedField<int>&
Login::returndata() const {
  // @@protoc_insertion_point(field_list:Login.returndata)
  return returndata_;
}
inline ::google::protobuf::RepeatedField<int>*
Login::mutable_returndata() {
  // @@protoc_insertion_point(field_mutable_list:Login.returndata)
  return &returndata_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Roomlist

// map<int64, string> roomlist = 1;
inline int Roomlist::roomlist_size() const {
  return roomlist_.size();
}
inline void Roomlist::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >&
Roomlist::roomlist() const {
  // @@protoc_insertion_point(field_map:Roomlist.roomlist)
  return roomlist_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >*
Roomlist::mutable_roomlist() {
  // @@protoc_insertion_point(field_mutable_map:Roomlist.roomlist)
  return roomlist_.MutableMap();
}

// int64 length = 2;
inline void Roomlist::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Roomlist::length() const {
  // @@protoc_insertion_point(field_get:Roomlist.length)
  return length_;
}
inline void Roomlist::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:Roomlist.length)
}

// -------------------------------------------------------------------

// Roommake

// string RoomName = 1;
inline void Roommake::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Roommake::roomname() const {
  // @@protoc_insertion_point(field_get:Roommake.RoomName)
  return roomname_.GetNoArena();
}
inline void Roommake::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Roommake.RoomName)
}
#if LANG_CXX11
inline void Roommake::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Roommake.RoomName)
}
#endif
inline void Roommake::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Roommake.RoomName)
}
inline void Roommake::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Roommake.RoomName)
}
inline ::std::string* Roommake::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:Roommake.RoomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Roommake::release_roomname() {
  // @@protoc_insertion_point(field_release:Roommake.RoomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Roommake::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:Roommake.RoomName)
}

// repeated int64 returndata = 2;
inline int Roommake::returndata_size() const {
  return returndata_.size();
}
inline void Roommake::clear_returndata() {
  returndata_.Clear();
}
inline ::google::protobuf::int64 Roommake::returndata(int index) const {
  // @@protoc_insertion_point(field_get:Roommake.returndata)
  return returndata_.Get(index);
}
inline void Roommake::set_returndata(int index, ::google::protobuf::int64 value) {
  returndata_.Set(index, value);
  // @@protoc_insertion_point(field_set:Roommake.returndata)
}
inline void Roommake::add_returndata(::google::protobuf::int64 value) {
  returndata_.Add(value);
  // @@protoc_insertion_point(field_add:Roommake.returndata)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Roommake::returndata() const {
  // @@protoc_insertion_point(field_list:Roommake.returndata)
  return returndata_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Roommake::mutable_returndata() {
  // @@protoc_insertion_point(field_mutable_list:Roommake.returndata)
  return &returndata_;
}

// -------------------------------------------------------------------

// Roominsert

// int64 index = 1;
inline void Roominsert::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Roominsert::index() const {
  // @@protoc_insertion_point(field_get:Roominsert.index)
  return index_;
}
inline void Roominsert::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Roominsert.index)
}

// repeated int64 returndata = 2;
inline int Roominsert::returndata_size() const {
  return returndata_.size();
}
inline void Roominsert::clear_returndata() {
  returndata_.Clear();
}
inline ::google::protobuf::int64 Roominsert::returndata(int index) const {
  // @@protoc_insertion_point(field_get:Roominsert.returndata)
  return returndata_.Get(index);
}
inline void Roominsert::set_returndata(int index, ::google::protobuf::int64 value) {
  returndata_.Set(index, value);
  // @@protoc_insertion_point(field_set:Roominsert.returndata)
}
inline void Roominsert::add_returndata(::google::protobuf::int64 value) {
  returndata_.Add(value);
  // @@protoc_insertion_point(field_add:Roominsert.returndata)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Roominsert::returndata() const {
  // @@protoc_insertion_point(field_list:Roominsert.returndata)
  return returndata_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Roominsert::mutable_returndata() {
  // @@protoc_insertion_point(field_mutable_list:Roominsert.returndata)
  return &returndata_;
}

// -------------------------------------------------------------------

// Chatmsg

// string chat = 1;
inline void Chatmsg::clear_chat() {
  chat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chatmsg::chat() const {
  // @@protoc_insertion_point(field_get:Chatmsg.chat)
  return chat_.GetNoArena();
}
inline void Chatmsg::set_chat(const ::std::string& value) {
  
  chat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Chatmsg.chat)
}
#if LANG_CXX11
inline void Chatmsg::set_chat(::std::string&& value) {
  
  chat_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Chatmsg.chat)
}
#endif
inline void Chatmsg::set_chat(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Chatmsg.chat)
}
inline void Chatmsg::set_chat(const char* value, size_t size) {
  
  chat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Chatmsg.chat)
}
inline ::std::string* Chatmsg::mutable_chat() {
  
  // @@protoc_insertion_point(field_mutable:Chatmsg.chat)
  return chat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chatmsg::release_chat() {
  // @@protoc_insertion_point(field_release:Chatmsg.chat)
  
  return chat_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chatmsg::set_allocated_chat(::std::string* chat) {
  if (chat != NULL) {
    
  } else {
    
  }
  chat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chat);
  // @@protoc_insertion_point(field_set_allocated:Chatmsg.chat)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Login_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login_MessageType>() {
  return ::Login_MessageType_descriptor();
}
template <> struct is_proto_enum< ::Roommake_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Roommake_MessageType>() {
  return ::Roommake_MessageType_descriptor();
}
template <> struct is_proto_enum< ::Roominsert_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Roominsert_MessageType>() {
  return ::Roominsert_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_rest_2eproto
